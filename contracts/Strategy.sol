// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {
    BaseStrategy,
    StrategyParams
} from "@yearnvaults/contracts/BaseStrategy.sol";
import {
    SafeERC20,
    SafeMath,
    IERC20,
    Address
} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

import "../interfaces/ComptrollerInterface.sol";
import "../interfaces/ICToken.sol";
import "../interfaces/ISwap.sol";
import "../interfaces/IVault.sol";


contract Strategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 public immutable wantDecimals = 6;
    uint256 public immutable cTokenDecimals = 8;

    // yearn interfaces
    IVault internal yVault;
    // IERC20 public want = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);

    // swap related variables
    ISwap public router;
    ISwap public sushiswapRouter = ISwap(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);
    IERC20 public weth = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
    // Should we ensure the swap will be within slippage params before performing it during normal harvest?
    bool public checkSlippageOnHarvest = true;
    uint256 public minRewardToWantPrice = 8000;

    // Lodestar related variables
    IERC20 public reward = IERC20(0xF19547f9ED24aA66b03c3a552D181Ae334FBb8DB);
    ICToken public cToken = ICToken(0x5E3F2AbaECB51A182f05b4b7c0f7a5da1942De90);
    ComptrollerInterface public unitroller = ComptrollerInterface(0x8f2354F9464514eFDAe441314b8325E97Bf96cdc);



    constructor(address _vault) public BaseStrategy(_vault) {
        
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;

        // set max approvals for cToken and swapRouter
        yVault = IVault(_vault);
        want = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);
        want.safeApprove(address(cToken), type(uint256).max);
        reward.safeApprove(address(sushiswapRouter), type(uint256).max);
    }

    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    function name() external view override returns (string memory) {
        return "StrategyLodeLendingOptimizer";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        // TODO: Build a more accurate estimate using the value of all positions in terms of `want`
        // current liquid balance of want plus deposited amount (cTokens) minus borrowed amount. 
        // optional add reward balance. 
        uint256 liquidBalance = balanceOfWant();
        return liquidBalance;
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position
    }

    function _repayLodestarBorrow(uint256 beforeBalance) internal returns (uint256 _profit, uint256 _loss){
        // TODO: write a function that repays the borrow, but first focus on the deposit stuff.
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // TODO: Do something to invest excess `want` tokens (from the Vault) into your positions
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)
        // NOTE: Function checks available balance minus debtOutstanding and then mints cTokens. 
        uint256 wantAvailable = want.balanceOf(address(this));
        if (wantAvailable > _debtOutstanding) {
            uint256 toDeposit = wantAvailable.sub(_debtOutstanding);
            cToken.mint(toDeposit);
            // TODO: write and initiate leverage up function
            // _leverage();
        }
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // TODO: Do stuff here to free up to `_amountNeeded` from all positions back into `want`
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`

        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded > totalAssets) {
            _liquidatedAmount = totalAssets;
            _loss = _amountNeeded.sub(totalAssets);
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    function liquidateAllPositions() internal override returns (uint256) {
        // TODO: Liquidate all positions and return the amount freed.
        return want.balanceOf(address(this));
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    //
    // Example:
    //
    //    function protectedTokens() internal override view returns (address[] memory) {
    //      address[] memory protected = new address[](3);
    //      protected[0] = tokenA;
    //      protected[1] = tokenB;
    //      protected[2] = tokenC;
    //      return protected;
    //    }
    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    {}

        /* Leverage functions */
    function deposited() public view returns (uint256) {
        return cToken.balanceOf(address(this));
    }

    // function borrowed() public view returns (uint256) {
    //     return vToken.balanceOf(address(this));

    // ----------------- REWARD RELATED -----------------
    function setMinRewardWantToPrice(uint256 newMinRewardToWantPrice)
        external
        onlyVaultManagers
    {
        require(newMinRewardToWantPrice >= 0 && newMinRewardToWantPrice <= MAX_BPS); // dev: minAAVEToWantPrice
        minRewardToWantPrice = newMinRewardToWantPrice;
    }

    function balanceOfRewards() public returns (uint256){
        uint256 totalRewards = unitroller.compAccrued(address(this));
        return totalRewards;
    }

    function _claimRewards() internal {
        unitroller.claimComp(address(this));
    } 

    function _fromRewardsToWant(uint256 amountIn, uint256 minOut) internal {
        // NOTE: Pool is on Sushi, so we can best swap using their direct functions
        // NOTE: This function is not optimized and can be frontrun. 
        // input params AmountIn, AmountOutMin, path[], to, deadline
        address[] memory path = new address[](3);
        path[0] = address(reward);
        path[1] = address(weth);
        path[2] = address(want);
        sushiswapRouter.swapExactTokensForTokens(amountIn, minOut, path, address(this), type(uint256).max);
    }

    function _claimRewardsAndGetMoreWant() internal {
        _claimRewards();
        uint256 rewardsAmount = reward.balanceOf(address(this));
        if (rewardsAmount == 0) {
            return;
        }
        //specify minimumAmountOut
        uint256 minWantOut = 0;
        if (checkSlippageOnHarvest) {
            minWantOut = rewardsToWant(rewardsAmount).mul(minAaveToWantPrice).div(MAX_BPS);
        }
        _fromRewardsToWant(rewards.Amount, minWantOut);
    }


    // ----------------- INTERNAL CALCS -----------------

    /**
     * @notice
     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
     *  to `want` (using the native decimal characteristics of `want`).
     * @dev
     *  Care must be taken when working with decimals to assure that the conversion
     *  is compatible. As an example:
     *
     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),
     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)
     *
     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
     * @return The amount in `want` of `_amtInEth` converted to `want`
     **/
    function ethToWant(uint256 _amtInWei) public view virtual override returns(uint256){
        return _amtInWei
    }

    function rewardToETH(uint256 rewardsAmount) public view returns (uint256){
        // TODO: Create correct and accurate price oracle
        uint256 rewardToETHAmount = rewardsAmount;
        return rewardToETHAmount;
    }

    function rewardToWant(uint256 rewardsAmount) public view returns (uint256){
        return ethToWant(rewardToETH(rewardsAmount));
    }

    function balanceOfWant() internal view returns (uint256) {
        return want.balanceOf(address(this));
    }

    function balanceOfCToken() internal view returns (uint256) {
        return cToken.balanceOf(address(this));
    }

}
